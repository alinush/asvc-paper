\subsection{aSVC From KZG Commitments to Lagrange Polynomials}
\label{s:asvc:from-kzg}

In this subsection, we present our aSVC from KZG commitments to Lagrange polynomials.
Similar to previous work, we represent a vector $\vect{v} = [v_0, v_1, \dots, v_{n-1}]$ as a polynomial $\phi(X)=\sum_{i\in[0,n)} \lagr_i(X)v_i$ in Lagrange basis~\cite{KZG10a,CDHK15,Tomescu20,GRWZ20}.
We use \textit{roots of unity} and ``store'' $v_i$ as $\phi(\omega^i)=v_i$.
This means that our Lagrange polynomials are $\lagr_i(X)=\prod_{j\in [0,n),j\ne i} \frac{X-\omega^j}{\omega^i - \omega^j}$.
For this to work \textit{efficiently}, we assume without loss of generality that $n$ is a power of two.

\parhead{Committing.}
A commitment to $\vect{v}$ is just a KZG commitment $c=g^{\phi(\tau)}$ to $\phi(X)$, where $\tau$ is the trapdoor of the KZG scheme (see \cref{s:prelim:polycommit:kzg}).
Similar to previous work~\cite{CDHK15}, the proving key includes commitments to all Lagrange polynomials $\ell_i = g^{\lagr_i(\tau)}$.
This means $c$ can be computed as $c=\prod_{i=1}^n (\ell_i)^{v_i}$ in $O(n)$ time without interpolating $\phi(X)$.
This also allows the commitment $c$ to be easily updated to $c'$ after adding $\delta$ to $v_i$.
Specifically, $c' = c\cdot (\ell_i)^{\delta}$, which is just a commitment to the new updated $\phi'(X)=\phi(X)+\delta\cdot\lagr_i(X)$.

\parhead{Proving.}
A normal proof $\pi_i$ for a single element $v_i$ is just a KZG proof for the evaluation of $\phi(X)$ at $\omega^i$ (see \cref{s:prelim:polycommit:kzg}).
Interestingly, we show this proof can be computed in $O(n)$ time without interpolating $\phi(X)$ (see \cref{s:asvc:from-kzg:algorithms}).
A subvector proof $\pi_I$ for for $v_I,I\subseteq[0,n)$ is just a KZG batch proof for the evaluations of $\phi(X)$ at all $(\omega^i)_{i\in I}$.

\parhead{Limitations.}
Next, we add support for (1) updating proofs, (2) aggregating proofs and (3) precomputing all individual proofs efficiently.
For aggregation, we use known techniques for aggregating KZG proofs via partial fraction decomposition (see \cref{s:prelim:partial-fraction-decomposition}).
For updating proofs efficiently, we introduce a new mechanism to reduce the update key size from linear to constant.
For precomputing all proofs, we use existing techniques for computing evaluation proofs fast in KZG polynomial commitments~\cite{FK20}.

\subsection{Partial Fraction Decomposition}
\label{s:prelim:partial-fraction-decomposition}

A key ingredient in our aSVC scheme is \textit{partial fraction decomposition}~\cite{PartialFractionDecomposition}, which we re-explain from the perspective of Lagrange interpolation.
First, let us rewrite the Lagrange polynomial for interpolating $\phi(X)$ given all $\left(\phi(\omega^i)\right)_{i\in I}$:
\begin{align}
\label{eq:lagr-poly-rewrite}
\lagr_i(X)=\prod_{j\in I, j\ne i} \frac{X-\omega^j}{\omega^i - \omega^j}=\frac{A_I(X)}{A'_I(\omega^i) (X-\omega^i)},\ \text{where}\ A_I(X)=\prod_{i\in I} (X-\omega^i)
\end{align}
Here, $A'_I(X)=\sum_{j\in[0,n)} A_I(X)/(X-\omega^j)$ is the formal derivative of $A_I(X)$~\cite{vG13ModernCh10}.
Next, for any $\phi(X)$, we can rewrite the Lagrange interpolation formula as $\phi(X) = A_I(X)\sum_{i\in[0,n)} \frac{y_i}{A'_I(\omega^i)(X-\omega^i)}$.
In particular, for $\phi(X)=1$, this implies $\frac{1}{A_I(X)} = \sum_{i\in[0,n)} \frac{1}{A'_I(\omega^i)(X-\omega^i)}$.
In other words, we can decompose $A_I(X)$ as:
\begin{align}
\frac{1}{A_I(X)} = \frac{1}{\prod_{i \in I} (X-\omega^i)} &= \sum_{i\in[0,n)} c_i\cdot \frac{1}{X-\omega^i},\ \text{where}\ c_i=\frac{1}{A'_I(\omega^i)}
\end{align}

$A_I(X)$ can be computed in $O(|I|\log^2{|I|}) $ using a \textit{subproduct tree} and DFT-based polynomial multiplication~\cite{vG13ModernCh10}.
Its derivative $A'_I(X)$ can be computed in $O(|I|)$ time and evaluated at all $\omega^i$'s in $O(|I|\log^2{|I|})$ time~\cite{vG13ModernCh10}.
Thus, all coefficients $c_i=\frac{1}{A'_I(\omega^i)}$ can be computed in $O(|I|\log^2{|I|})$ time.
For the special case of $I=[0,n)$, we have $A_I(X)=A(X)=\prod_{i\in[0,n)} (X-\omega^i)=X^n - 1$ and $A'(\omega^i)=n\omega^{-i}$ (see \cref{app:xn-1-derivative}).
In this case, any $c_i$ can be computed in $O(1)$ time.

\subsubsection{Aggregating Proofs}
\label{s:asvc:from-kzg:aggregating-proofs}
We build upon Buterin's observation~\cite{Buterin20UsingPoly} that partial fraction decomposition (see \cref{s:prelim:partial-fraction-decomposition}) can be used to aggregate KZG evaluation proofs.
Since our VC proofs are KZG proofs, we show how to aggregate a set of proofs $(\pi_i)_{i\in I}$ for elements $v_i$ of $\vect{v}$ into a single constant-sized proof $\pi_I$ for the $I$-subvector of $\vect{v}$.

Recall that $\pi_i$ is a KZG commitment to  $q_i(X)=\frac{\phi(X)-v_i}{X-\omega^i}$ and $\pi_I$ is a commitment to $q(X) = \frac{\phi(X)-R(X)}{A_I(X)}$, where $A_I(X)=\prod_{i\in I} (X-\omega^i)$ and $R(X)$ is interpolated such that $R(\omega^i)=v_i,\forall i\in I$.
Our goal is to find coefficients $c_i\in \Zp$ such that $q(X)=\sum_{i\in I} c_i q_i(X)$ and thus aggregate $\pi_I=\prod_{i\in I} \pi_i^{c_i}$.
We observe that:
\begin{align}
q(X)&= \phi(X)\frac{1}{A_I(X)}- R(X)\frac{1}{A_I(X)}
		= \phi(X)\sum_{i\in I} \frac{1}{A_I'(\omega^i)(X-\omega^i)} - \left(A_I(X)\sum_{i\in I} \frac{v_i}{A_I'(\omega^i)(X-\omega^i)}\right)\cdot \frac{1}{A_I(X)} \\
		&= \sum_{i\in I} \frac{\phi(X)}{A_I'(\omega^i)(X-\omega^i)} - \sum_{i\in I} \frac{v_i}{A_I'(\omega^i)(X-\omega^i)}
		= \sum_{i\in I} \frac{1}{A_I'(\omega^i)}\cdot \frac{\phi(X) - v_i}{X-\omega^i}
		 = \sum_{i\in I} \frac{1}{A_I'(\omega^i)}\cdot q_i(X)
\end{align}
To conclude, to aggregate the $\pi_i$'s into $\pi_I$, we compute all $c_i={1}/{A_I'(\omega^i)}$ using $O(\vert I\vert \log^2{\vert I \vert})$ field operations (see \cref{s:prelim:partial-fraction-decomposition}) and compute $\pi_I=\prod_{i\in I} \pi_i^{c_i}$ with an $O(|I|)$-sized multi-exponentiation.

\subsubsection{Updating Proofs}
\label{s:asvc:from-kzg:updating-proofs}

When updating $\pi_i$ after a change to $v_j$, it could be that either (1) $i=j$ or that (2) $i\ne j$.
First, recall that $\pi_i$ is a KZG commitment to $q_i(X)=\frac{\phi(X)-v_i}{X-\omega^i}$.
Second, recall that, after a change $\delta$ to $v_j$, the polynomial $\phi(X)$ is updated to $\phi'(X)=\phi(X)+\delta\lagr_j(X)$.
We refer to the party updating their proof $\pi_i$ as the \textit{proof updater}.

\parhead{The $i=j$ Case.}
Consider the quotient polynomial $q_i'(X)$ in the updated proof $\pi_i'$ after $v_i$ changed to $v_i+\delta$:
\begin{align}
q_i'(X)&=\frac{\phi'(X)-(v_i+\delta)}{X-\omega^i}=\frac{\left(\phi(X) + \delta\lagr_i(X)\right) - v_i -\delta}{X-\omega^i}=\frac{\phi(X) - v_i}{X-\omega^i}-\frac{\delta(\lagr_i(X)-1)}{X-\omega^i} = q_i(X) + \delta\left(\frac{\lagr_i(X)-1}{X-\omega^i}\right)
\end{align}

This means the proof updater needs a KZG commitment to $\frac{\lagr_i(X)-1}{X-\omega^i}$, which is just a KZG evaluation proof that $\lagr_i(\omega^i)=1$.
This can be addressed very easily by making this commitment part of $\upk_i$, which the proof updater always has.
(Recall that, in this $i=j$ case, the proof updater called $\vcproofupdate(\pi_i, \delta,i,\upk_i,\upk_i)$.)
To conclude, to update $\pi_i$, the proof updater obtains $u_i=g^{\frac{\lagr_i(\tau)-1}{\tau - \omega^i}}$ from $\upk_i$ and computes $\pi_i'=\pi_i \cdot \left(u_i\right)^\delta$.

\parhead{The $i\ne j$ Case.}
Now, consider the quotient polynomial $q_i'(X)$ after $v_j$ changed to $v_j+\delta$:
\begin{align}
q_i'(X)&=\frac{\phi'(X)-v_i}{X-\omega^i}=\frac{\left(\phi(X) + \delta\lagr_j(X)\right) - v_i}{X-\omega^i}=\frac{\phi(X) - v_i}{X-\omega^i}-\frac{\delta\lagr_j(X)}{X-\omega^i} = q_i(X) + \delta\left(\frac{\lagr_j(X)}{X-\omega^i}\right)
\end{align}

In this case, the proof updater needs a KZG commitment to $\frac{\lagr_j(X)}{X-\omega^i}$.
For this, we will make sure $\upk_j$ gives the proof updater \textit{extra information} to allow them to reconstruct this commitment in $O(1)$ time.
Here, our VC API differs from that of Chepurnoy et al~\cite{CPZ18} as we assume the proof updater gets both $\upk_i$ and $\upk_j$.
We stress this is reasonable in the stateless cryptocurrency setting where each user has to store their proof $\pi_i$ and $\upk_i$ anyway as they process the $(\delta, j, \upk_j)$ updates (see \cref{s:stateless-cryptocurrency}).

\paragraph{Update Keys for the $i\ne j$ Case.}
To understand what extra information the proof updater with $\upk_i$ needs in order to reconstruct a commitment $u_{i,j}$ to $U_{i,j}(X)=\frac{\lagr_j(X)}{X-\omega^i}$, let us rewrite it as $U_{i,j}(X)=\frac{A(X)}{A'(\omega^j)(X-\omega^j)(X-\omega^i)}$.
Next, note that since $A'(\omega^j) =n\omega^{-j}$ is a constant (see \cref{app:xn-1-derivative}), the proof updater need only reconstruct a KZG commitment to $W_{i,j}(X)=\frac{A(X)}{(X-\omega^j)(X-\omega^i)}$.

Our key idea is to make $a_j=g^{{A(\tau)}/(\tau-\omega^j)}$ part of $\upk_j,\forall j\in[0,n)$.
This way, the proof updater, who has both $\upk_i$ and $\upk_j$, can reconstruct a commitment $w_{i,j}$ to $W_{i,j}(X)$ using partial fraction decomposition.
Specifically, the proof updater will compute $c_1,c_2\in\Zp$ such that $\frac{1}{(X-\omega^j)(X-\omega^i)} = c_1 \frac{1}{X-\omega^j} + c_2\frac{1}{X-\omega^i}$ (see \cref{s:prelim:partial-fraction-decomposition}).
Multiplying by $A(X)$, we have $W_{i,j}(X)=\frac{A(X)}{(X-\omega^j)(X-\omega^i)} = c_1 \frac{A(X)}{X-\omega^j} + c_2\frac{A(X)}{X-\omega^i}$.
Thus, the proof updater can compute $w_{i,j} = a_j^{c_1} a_i^{c_2}$ and then get $u_{i,j}=\left(w_{i,j}\right)^{\frac{1}{A'(\omega^j)}}$.

To summarize, the proof updater will:
(1) Obtain $a_i = g^{A(\tau)/(\tau-\omega^i)}$ and $a_j = g^{A(\tau)/(\tau-\omega^j)}$ from $\upk_i$ and $\upk_j$, respectively,
(2) Compute $d_j=1/(A'(\omega^j))={1}/{(n\omega^{-j})}=\omega^j/n$,
(2) Use partial fraction decomposition to compute $w_{i,j}=g^{A(\tau)/[(\tau-\omega^j)(\tau-\omega^i)]}$ from $a_i$ and $a_j$,
(3) Compute $u_{i,j}=\left(w_{i,j}\right)^{d_j} = g^{\frac{A(\tau)}{A'(\omega^j)(\tau-\omega^j)(\tau-\omega^i)}}=g^{\lagr_j(\tau)/(\tau-\omega^i)}$,
(4) Compute the updated proof $\pi_i' = \pi_i \cdot (u_{i,j})^\delta$.

\subsubsection{Precomputing All Proofs}
\label{s:asvc:from-kzg:precomp}
The Feist-Khovratovich~\cite{FK20} technique can be used to compute all proofs $(\pi_i)_{i\in[0,n)}$ in $O(n\log{n})$ time.
(Note that $\phi(X)$ can be interpolated in $O(n\log{n})$ time via an inverse DFT.)
As a result, any subset of $(\pi_i)_{i\in I}$ proofs can be aggregated into an $I$-subvector proof in $O(\vert I \vert \log^2{|I|})$ time.
This is useful for reducing the time to compute subvector proofs (see \cref{t:asvc-comparison}).
Furthermore, it helps proof serving nodes in stateless cryptocurrencies compute proofs faster (see \cref{s:stateless-cryptocurrency:proof-serving-nodes}).


\subsubsection{aSVC Algorithms}
\label{s:asvc:from-kzg:algorithms}
In this subsection, we give a full description of how our scheme implements the aSVC API from \cref{s:prelim:vcs:api}.
To support verifying $I$-subvector proofs, our verification key is $O(|I|)$-sized.
\\

\api $\vcsetup(1^\lambda, n) \rightarrow \prk,\vrk,(\upk_j)_{j\in[0,n)}$.
Generates $n$-SDH public parameters $g,g^\tau,g^{\tau^2},\dots,g^{\tau^n}$.
Computes $a=g^{A(\tau)}$, where $A(X)=X^n - 1$.
Computes $a_i=g^{A(\tau)/(X-\omega^i)}$ and $\ell_i = g^{\lagr_i(\tau)}, \forall i\in[0,n)$.
Computes KZG proofs $u_i=g^{\frac{\lagr_i(\tau)-1}{X-\omega^i}}$ for $\lagr_i(\omega^i) = 1$.
Sets $\upk_i = (a_i, u_i)$.
Sets $\prk = \left((g^{\tau^i})_{i\in[0,n]},(\ell_i)_{i\in[0,n)}, (\upk_i)_{i\in[0,n)}\right)$.
Sets $\vrk = ((g^{\tau^i})_{i\in [0,|I|]},a)$.


\api $\vccommit(\prk, \vect{v}) \rightarrow c$.
Returns $c=\prod_{i\in[0,n)} (\ell_i)^{v_i}$.

\api $\vcopenpos(\prk, I, \vect{v}) \rightarrow \pi_I$.
Computes $A_I(X)=\prod_{i\in I} (X-\omega^i)$ in $O(\vert I\vert \log^2{\vert I \vert})$ time.
Divides $\phi(X)$ by $A_I(X)$ in $O(n\log{n})$ time, obtaining a quotient $q(X)$ and a remainder $r(X)$.
Returns $\pi_I = g^{q(\tau)}$.
(We give an $O(n)$ time algorithm in \cref{s:complexity-lagrange-asvc} for the $\vert I\vert = 1$ case.)

\api $\vcverifypos(\vrk, c, \vect{v}_I, I, \pi_I) \rightarrow T/F$.
Computes $A_I(X)=\prod_{i\in I} (X-\omega^i)$ in $O(\vert I\vert \log^2{\vert I \vert})$ time and commits to it as $g^{A_I(\tau)}$ in $O(\vert I \vert)$ time.
Interpolates $R_I(X)$ such that $R_I(i) = v_i,\forall i \in I$ in $O(\vert I\vert \log^2{\vert I \vert})$ time and commits to it as $g^{R_I(\tau)}$ in $O(\vert I \vert)$ time.
Returns $T$ iff. $e(c/g^{R_I(\tau)},g)=e(\pi_I, g^{A_I(\tau)})$.
(When $I=\{i\}$, $A_I(X)=X-\omega^i$ and $R_I(X)=v_i$.)

\api $\vcverifyupk(\vrk,i, \upk_i) \rightarrow T/F$.
First, checks if $e(a_i, g^\tau/g^{\omega^i}) = e(a,g)$.
(i.e., verify that $\omega^i$ is a root of $X^n-1$, which is committed in $a$.)
Second, computes $\ell_i=a_i^{1/A'(\omega^i)}=g^{\lagr_i(\tau)}$ and checks if $e(\ell_i/g^1, g) =e(u_i,g^\tau/g^{\omega^i})$.
(i.e., verify that $\lagr_i(\omega^i) = 1$.)

\api $\vccommupdate(c, \delta, j,\upk_j)\rightarrow c'$.
Computes $\ell_j=a_j^{1/A'(\omega^j)}$.
Returns $c'=c\cdot (\ell_j)^\delta$.

\api $\vcproofupdate(\pi_i, \delta, j, \upk_i, \upk_j)\rightarrow \pi'_i$.
If $i=j$, returns $\pi_i'=\pi_i \cdot (u_i)^\delta$.
If $i\ne j$, computes $c_1,c_2\in \Zp$ such that $\frac{1}{(X-\omega^j)(X-\omega^i)} = c_1 \frac{1}{X-\omega^j} + c_2\frac{1}{X-\omega^i}$ (see \cref{s:prelim:partial-fraction-decomposition}).
Computes $w_{i,j}=a_j^{c_1}\cdot a_i^{c_2}$ and $u_{i,j}=w_{i,j}^{1/A'(\omega^j)}$.
Returns $\pi_i'=\pi_i \cdot (u_{i,j})^\delta$.

\api $\vcaggregateproofs(I, (\pi_i)_{i\in I})\rightarrow \pi_I$.
Computes $A_I(X)=\prod_{i\in I} (X-\omega^i)$ in $O(\vert I\vert \log^2{\vert I \vert})$ time.
Computes the derivative $A'_I(X)$ of $A_I(X)$ in $O(\vert I\vert)$ time.
Computes $c_i = (A'_I(\omega^i))_{i\in I}$ in $O(\vert I\vert \log^2{\vert I \vert})$ time using a multipoint polynomial evaluation~\cite{vG13ModernCh10}.
Returns $\pi_I = \prod_{i\in I} \pi_i^{c_i}$.

\subsubsection{Distributing the Trusted Setup}
\label{s:asvc:from-kzg:public-params}
Our VC requires a trusted setup phase that computes its public parameters.
To guarantee nobody learns the trapdoor $\tau$, this phase should be distributed via MPC protocols ~\cite{BGG18,BGM17,BCG+15}.
Unfortunately, the most efficient MPC protocols only output $(g^{\tau^i})$'s~\cite{BGM17}.
This means we can either (1) use less efficient protocols that output our full public parameters or (2) find a way to derive the remaining public parameters from the $(g^{\tau^i})$'s.
Fortunately, all remaining public parameters are easy to derive.

First, the commitment $a=g^{A(\tau)}$ to $A(X)=X^{n} - 1$ can be computed in $O(1)$ time via an exponentiation.
Second, the commitments $\ell_i=g^{\lagr_i(\tau)}$ to Lagrange polynomials can be computed via a single DFT on the $(g^{\tau^i})$'s~\cite[Sec 3.12.3, pg. 97]{Virza17}.
% Also in BCG+15: Oakland paper I-C-2, page 5
Third, each $a_i = g^{A(\tau)/(\tau -\omega^i)}$ is just a bilinear accumulator membership proof for $\omega^i$ w.r.t. $A(X)$.
Thus, all $a_i$'s can be computed in $O(n\log{n})$ time via the FK technique~\cite{FK20}.
Lastly, we need a way to compute all $u_i =  g^{\frac{\lagr_i(\tau)-1}{X-\omega^i}}$.

\parhead{Computing All $u_i$'s Fast.}
Inspired by the FK technique~\cite{FK20}, we show how to compute all $n$ $u_i$'s in $O(n\log{n})$ time using a single DFT on group elements.
First, note that $u_i=g^{\frac{\lagr_i(\tau)-1}{X-\omega^i}}=g^{Q_i(\tau)}$ is a KZG evaluation proof for $\lagr_i(\omega^i)=1$, which means:
\begin{align}
\lagr_i(X)=Q_i(X)(X-\omega^i) + 1
\end{align}
Let $\psi_i(X)=\frac{A(X)}{X-\omega^i}=\frac{X^n - 1}{X-\omega^i}$, and let $\pi_i=g^{q_i(\tau)}$ be an evaluation proof for $\psi_i(\omega^i)$ such that:
\begin{align}
\psi_i(X)=q_i(X)(X-\omega^i) + \psi_i(X)
\end{align}
We argue that $Q_i(X)=\frac{1}{A'(\omega^i)}q_i(X)$ and thus each $u_i=g^{Q_i(\tau)}$ can be derived from $\pi_i = g^{q_i(\tau)}$ as $u_i = \pi_i^{\frac{1}{A'(\omega^i)}}$.
For this, we will use the fact that $\lagr_i(X)=\frac{A(X)}{A'(\omega^i)(X-\omega^i)}=\frac{1}{A'(\omega^i)}\psi_i(X)$ and $\psi(\omega^i)=A'(\omega^i)$ (see \cref{eq:lagr-poly-rewrite}):
\begin{align}
\psi_i(X) &= q_i(X)(X-\omega^i) + \psi_i(\omega^i)\Rightarrow\\
\frac{1}{A'(\omega^i)}\psi_i(X) &= \frac{1}{A'(\omega^i)}[q_i(X)(X-\omega^i) + A'(\omega^i)]\Rightarrow\\
\lagr_i(X) &= \left(\frac{1}{A'(\omega^i)}q_i(X)\right) \cdot (X-\omega^i) + 1\Rightarrow Q_i(X) = \frac{1}{A'(\omega^i)}q_i(X)
\end{align}

Thus, computing all $u_i$'s reduces to computing $n$ evaluation proofs $\pi_i$ for $\psi_i(\omega^i)$.
However, since each proof $\pi_i$ is for a \textit{different} polynomial $\psi_i(X)$, all $\pi_i$'s would still require $O(n^2)$ time to compute naively.
We fix this next by leveraging the ``structure'' of $\psi_i(X)$ when divided by $X-\omega^i$.
Specifically, in \cref{s:computing-all-uis}, we show that:
\begin{align}
\label{eq:ui-qi}
q_i(X) &= \sum_{j\in [0,n-2]} (j+1)(\omega^i)^j X^{(n - 2) - j},\forall i \in [0,n)
\end{align}
Let $H_j(X) = (j+1) X^{(n-2)-j}$.
Then:
\begin{align}
q_i(X) &= \sum_{j\in [0,n-2]} H_j(X) \omega^{ij},\forall i \in [0,n)
\end{align}
In particular, if $h_j$ and $\pi_i$ are KZG commitments to $H_j(X)$ and $q_i(X)$ respectively, we have:
\begin{align}
\pi_i &= \prod_{j\in [0,n-2]} h_j^{(\omega^{ij})},\forall i \in [0,n)
\end{align}
Next, recall that the Discrete Fourier Transform (DFT) \textit{on a vector of group elements} $\vect{a}=[a_0, a_1, \dots, a_{n-1}]\in \G^n$ is:
\begin{align}
\mathsf{DFT}_n(\vect{a}) = \vect{\hat{a}}=[\hat{a}_0, \hat{a}_1, \dots, \hat{a}_{n-1}]\in \G^n,\ \text{where}\ \hat{a}_i= \prod_{j\in [0,n)} a_j^{(\omega^{ij})}
\end{align}

If we let $\vect{\pi}=[\pi_0, \pi_1, \dots, \pi_{n-1}]$ and $\vect{h} = [h_0, h_1, \dots, h_{n-2}, 1_\G, 1_\G]$, it  follows that:

\begin{align}
\vect{\pi} = \mathsf{DFT_n}(\vect{h})
\end{align}

Thus, we can compute all $\pi_i$'s in $O(n\log{n})$ time with a single DFT on the $h_i$'s.
(All $n$ $h_i$'s can be computed in $O(n)$ time.)
Then, we can compute each $u_i=\pi_i^{\frac{1}{A'(\omega^i)}}$ in $O(n)$ time.

\subsubsection{Correctness and Security}
\label{s:svc:correctness-and-security}
The correctness of our aSVC schemes follows naturally from Lagrange interpolation.
Aggregation and proof updates are correct by the arguments laid out in \cref{s:asvc:from-kzg:aggregating-proofs,s:asvc:from-kzg:updating-proofs}, respectively.
Subvector proofs are correct by the correctness of KZG batch proofs~\cite{KZG10a}.

The security of our aSVC schemes does \textit{not} follow naturally from the security of KZG polynomial commitments.
Specifically, as pointed out in~\cite{GRWZ20}, two inconsistent subvector proofs do \textit{not} lead to a direct break of KZG's \textit{batch evaluation binding}, as defined in~\cite[Sec. 3.4]{KZG10a}.
To address this, we propose a stronger batch evaluation binding definition (see \cref{def:kzg:batch-opening-binding} in \cref{s:kzg-batch-def}) and prove KZG satisfies it under $n$-SBDH.
This new definition is directly broken by two inconsistent subvector proofs, which implies our aSVC is secure under $n$-SBDH.
Lastly, we prove update key uniqueness holds unconditionally in \cref{s:update-key-uniqueness-proof}.
