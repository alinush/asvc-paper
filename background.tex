\section{Preliminaries}
\label{s:prelim}

\parhead{Notation.}
Let $\lambda$ denote our security parameter.
Let $\G_1,\G_2$ be groups of prime order $p$ endowed with a \textit{pairing} $e : \G_1 \times \G_2 \rightarrow \G_T$~\cite{MVO91,Joux00}.
(We assume symmetric pairings where $\G_1=\G_2$ for simplicity of exposition.)
Let $\Gho$ denote a hidden-order group.
We will use multiplicative notation for the group operations in $\Gho,\G_1,\G_2$ and $\GT$.
Let $\Zp$ denote a finite field of prime order $p$.
Let $\omega$ denote a primitive $n$th root of unity~\cite{vG13ModernCh8}.
Let $\poly(\cdot)$ denote any function upper-bounded by some univariate polynomial.
Let $\negl(\cdot)$ denotes any negligible function.
Let $\log{x}$ and $\lg{x}$ be shorthand for $\log_2{x}$.
Let $[i,j] = \{i,i+1,\dots,j-1,j\}$, $[0,n) =[0,n-1]$ and $[n]=[1,n]$.
Let $\vect{v}=(v_i)_{i\in[0,n)}$ denote a vector of size $n$ with elements $v_i\in \Zp$.

\subsection{Lagrange Polynomial Interpolation}
\label{s:prelim:interpolation}
Given $n$ pairs $(x_i, y_i)_{i\in[0,n)}$, we can find or \textit{interpolate} the \textit{unique} polynomial $\phi(X)$ of degree $<n$ such that $\phi(x_i) = y_i, \forall i\in[0,n)$ using \textit{Lagrange interpolation}~\cite{BT04} in $O(n\log^2{n})$ time~\cite{vG13ModernCh10} as:
\begin{align}
\phi(X) &= \sum_{i\in[0,n)} \lagr_i(X) y_i,\ \text{where}\ \lagr_i(X) = \prod_{\substack{j\in [0,n)\\j\ne i}}\frac{X-x_j}{x_i-x_j}
\end{align}

Recall that a \textit{Lagrange polynomial} $\lagr_i(X)$ has the property that $\lagr_i(x_i) = 1$ and $\lagr_i(x_j)=0, \forall i,j\in[0,n)$ with $j \ne i$.
Also, keep in mind that $\lagr_i(X)$ is defined in terms of the \textit{interpolation domain} $(x_i)_{i\in [0,n)}$.
Throughout this paper, the domain will be either $(\omega^i)_{i\in[0,n)}$ or $(\omega^i)_{i\in I}, I\subset [0,n)$.

\subsection{KZG Polynomial Commitments}
\label{s:prelim:polycommit:kzg}

Kate, Zaverucha and Goldberg (KZG) proposed a \textit{constant-sized} commitment scheme for degree $n$ polynomials $\phi(X)$ based on the $n$-S(B)DH assumption~\cite{BB08,Goyal07}.
Importantly, an \textit{evaluation proof} for any $\phi(a)$ is constant-sized and constant-time to verify; it does not depend in any way on the degree of the committed polynomial.
KZG requires $n$-SDH public parameters $(g^{\tau^i})_{i\in[0,n]}$ where $\tau$ denotes a trapdoor.
(These parameters are computed via a \textit{trusted setup} which can be decentralized with MPC protocols~\cite{BGG18,BGM17}.)
KZG is computationally-hiding under the discrete log assumption and computationally-binding under $n$-SDH~\cite{KZG10a}.

\parhead{Committing.}
Let $\phi(X)$ denote a polynomial of degree $d\le n$ with coefficients $c_0, c_1, \dots, c_d$ in $\Zp$.
A KZG commitment to $\phi(X)$ is a single group element $C = \prod_{i=0}^d {\left(g^{\tau^i}\right)^{c_i}} = g^{\sum_{i=0}^d c_i \tau^i} = g^{\phi(\tau)}$.
Committing to $\phi(X)$ takes $\Theta(d)$ time.

\parhead{Proving One Evaluation.}
To compute an \textit{evaluation proof} that $\phi(a) = y$, KZG leverages the polynomial remainder theorem, which says $\phi(a) = y \Leftrightarrow \exists q(X)\ \text{such that}\ \phi(X) - y = q(X)(X-a)$.
The proof is just a KZG commitment to $q(X)$: a single group element $\pi=g^{q(\tau)}$.
Computing the proof takes $\Theta(d)$ time.
To verify $\pi$, one checks (in constant time) if
$
e(C / g^y, g)            = e(\pi, g^{\tau}/g^a) \Leftrightarrow
e(g^{\phi(\tau) - y}, g) = e(g^{q(\tau)},g^{\tau-a})\Leftrightarrow
e(g,g)^{\phi(\tau)-y}   = e(g,g)^{q(\tau)(\tau-a)} \Leftrightarrow
{\phi(\tau)-y}          = q(\tau)(\tau-a)
$.

\parhead{Proving Multiple Evaluations.}
Given a set of points $I$ and their evaluations $\{\phi(i)\}_{i\in I}$, KZG can prove all evaluations with a constant-sized \textit{batch proof} rather than $|I|$ individual proofs~\cite{KZG10a}.
The prover computes an \textit{accumulator polynomial} $a(X)=\prod_{i\in I} (X-i)$ in $\Theta(|I|\log^2{|I|})$ time and computes $\phi(X)/a(X)$ in $\Theta(d\log{d})$ time, obtaining a quotient $q(X)$ and remainder $r(X)$.
The batch proof is $\pi=g^{q(\tau)}$.

To verify $\pi$ against $\{\phi(i)\}_{i\in I}$ and $C$, the verifier first computes $a(X)$ from $I$ and interpolates $r(X)$ such that $r(i)=\phi(i), \forall i \in I$ in $\Theta(|I|\log^2{|I|})$ time (see \cref{s:prelim:interpolation}).
Next, she computes $g^{a(\tau)}$ and $g^{r(\tau)}$.
Finally, she checks if $e(C / g^{r(\tau)}, g) = e(g^{q(\tau)}, g^{a(\tau)})$.
We stress that batch proofs are only useful when $|I| \le d$.
Otherwise, if $|I| > d$, the verifier can interpolate $\phi(X)$ directly from the evaluations, which makes verifying any $\phi(i)$ trivial.

\subsection{Account-based Stateless Cryptocurrencies}
\label{s:prelim:stateless-cryptocurrency}

In a stateless cryptocurrency based on VCs~\cite{CPZ18}, there are \textit{miners} running a permissionless consensus algorithm~\cite{Nakamoto08} and \textit{users}, numbered from $0$ to $n-1$ who have \textit{accounts} with a \textit{balance} of coins.
($n$ can be unbounded if the VC is unbounded.)
For simplicity of exposition, we do not give details on the consensus algorithm, on transaction signature verification and on monetary policy.
These all remain the same as in previous stateful cryptocurrencies.

\parhead{The (Authenticated) State.}
The \textit{state} is an \textit{authenticated data structure (ADS)} mapping each user $i$'s \textit{public key} to their account balance $\bal_i$.
(In practice, the mapping is also to a \textit{transaction counter} $c_i$, which is necessary to avoid transaction replay attacks.
We address this in \cref{s:discussion:txn-counters}.)
Importantly, miners and users are \textit{stateless}: they do not store the state, just its \textit{digest} $d_t$ at the latest block $t$ they are aware of.
Additionally, users store a proof $\pi_{i,t}$ for their account balance that verifies against $d_t$.

\parhead{Miners.}
Despite miners being stateless, they can still validate transactions, assemble them into a new \textit{block}, and propose that block.
Specifically, a miner can verify every new transaction spends valid coins by checking the sending user's balance against the latest digest $d_t$.
This requires each user $i$ who sends coins to include her proof $\pi_{i,t}$ in her transaction.
However, user $i$ does not need to include the recipient $j$'s proof $\pi_{j,t}$ in the transaction.

Once the miner has a set $V$ of valid transactions, he can use them to create the next block ${t+1}$ and propose it.
The miner obtains this new block's digest $d_{t+1}$ by ``applying'' all transactions in $V$ to $d_t$.
When other miners receive this new block ${t+1}$, they can validate its transactions from $V$ against $d_t$ and check that the new digest $d_{t+1}$ was produced correctly from $d_t$ by ``reapplying'' all the transactions from $V$.

\parhead{Users.}
When creating a transaction \tx for block $t+1$, user $i$ includes her proof $\pi_{i,t}$ for miners to verify she has sufficient balance.
When a user $i$ sees a new block ${t+1}$, she can update her proof $\pi_{i,t}$ to a new proof $\pi_{i,t+1}$, which verifies against the new digest $d_{t+1}$.
For this, the user will look at all changes in balances $(j, \Delta\bal_j)_{j\in J}$, where $J$ is the set of users with transactions in block ${t+1}$, and ``apply'' those changes to her proof.
Similarly, miners can also update proofs of pending transactions which did not make it in block $t$ and now need a proof w.r.t. $d_{t+1}$

Users assume that the consensus mechanism produces correct blocks.
As a result, they do \textit{not} need to verify transactions in the block; they only need to update their own proof.
Nonetheless, since block verification is stateless and fast, users could easily participate as block validators, should they choose to.
