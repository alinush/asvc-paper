\section{A Highly-efficient Stateless Cryptocurrency}
\label{s:stateless-cryptocurrency}

In this section, we present a stateless cryptocurrency that improves over Edrax~\cite{CPZ18} in both computation and communication efficiency.
We adopt Edrax's elegant design by replacing their VC with our secure \textit{aggregatable} subvector commitment (aSVC) scheme from \cref{s:asvc:from-kzg}.
As a result, our stateless cryptocurrency has smaller, aggregatable proofs and smaller update keys.
This leads to smaller, faster-to-verify blocks for miners and faster proof synchronization times for users (see \cref{t:stateless-comparison}).
Furthermore, our verifiable update keys reduce the storage overhead of miners from $O(n)$ update keys to $O(1)$.
We also address a denial of service (DoS) attack in Edrax's design.

\subsection{From VCs to Stateless Cryptocurrencies}
\label{s:stateless-cryptocurrency:edrax}
In this section, we re-introduce Edrax's design, which we adopt and slightly modify.
Edrax pioneered the idea of building account-based, stateless cryptocurrencies on top of any VC scheme~\cite{CPZ18}.
In contrast, previous approaches were based on \textit{authenticated dictionaries (ADs)}~\cite{RMCI17,Buterin17}, for which efficient constructions with updatable proofs and digests are not known yet.
(The key-value map commitment by Boneh et al.~\cite{BBF18} could work, but its efficiency and updatability in the context of stateless cryptocurrencies remains to be explored.)
As a result, these AD-based approaches were \textit{interactive}, requiring user $i$ to ask a \textit{proof serving node} for user $j$'s proof in order to create a transaction sending money to $j$.

\parhead{Trusted Setup.}
To support up to $n$ users, public parameters $(\prk,\vrk,(\upk_i)_{i\in[0,n)})\leftarrow \vcsetup(1^{\lambda}, n)$ are generated via a \textit{trusted setup}, which can be decentralized using MPC protocols~\cite{BGM17,BGG18}.
Miners need to store all $O(n)$ update keys to propose blocks and to validate blocks (see \cref{s:stateless-cryptocurrency:dos-update-key}).
The $\prk$ is only needed for \textit{proof serving nodes} (see \cref{s:stateless-cryptocurrency:proof-serving-nodes}).

\parhead{The (Authenticated) State.}
The state is a vector $\vect{v}=(v_i)_{i\in[0,n)}$ of size $n$ that maps user $i$ to $v_i=(\addr_i|\bal_i)\in \Zp$, where $\bal_i$ is her balance and $\addr_i$ is her \textit{address}, which we define later.
(We discuss including transaction counters for preventing replay attacks in \cref{s:discussion:txn-counters}.)
Importantly, since $p \approx 2^{256}$, the first 224 bits of $v_i$ are used for $\addr_i$ and the last 32 bits for $\bal_i$.

The genesis block's state is the all zeros vector.
Its digest $d_0$ is computed as $d_0, \pi_0 \leftarrow \vccommitempty(\vrk)$.
Initially, each user $i$ is \textit{unregistered} and starts with $\pi_{i,0}=\pi_0$ as their initial proof, which verifies correctly $\forall i$: $\vcverifypos(\vrk, d_0, 0, i,\pi_{i,0})=T$.

\parhead{``Full'' vs. ``traditional'' Public Keys.}
User $i$'s address is computed as $\addr_i=H(\PK_i)$, where $\PK_i=(i,\upk_i,\tpk_i)$ is her \textit{full public key}.
Here, $\tpk_i$ denotes a \textit{``traditional'' public key} for a digital signature scheme, with corresponding secret key $\tsk_i$ used to authorize user $i$'s transactions.
To avoid confusion, we will clearly refer to public keys as either ``full'' or ``traditional.''

\parhead{Registering via \inittxn Transactions.}
\inittxn transactions are used to \textit{register} new users and assign them a unique, ever-increasing number from $1$ to $n$.
For this, each block $t$ stores a \textit{count of users registered} so far $\cnt_t$.
To register, a user generates a \textit{traditional secret key} $\tsk$ with a corresponding \textit{traditional public key} $\tpk$.
Then, she broadcasts an \inittxn transaction:
$$\tx=[\inittxn, \tpk]$$
A miner working on block ${t+1}$ who receives $\tx$, proceeds as follows.
\begin{enumerate}
\item He sets $i=\cnt_{t+1}$ and increments the count $\cnt_{t+1}$ of registered users,
\item He updates the VC using a call to $d_{t+1}=\vccommupdate(d_{t+1}, (\addr_i\vert 0), i, \upk_i)$,
\item He incorporates $\tx$ in his block $t+1$ as $\tx' = [\inittxn, (i, \upk_i,\tpk_i)]=[\inittxn, \PK_i]$.
\end{enumerate}

The full public key with $\upk_i$ is included so other users can correctly update their VC when they process $\tx'$.
(The index $i$ is not necessary, since it can be computed from the block's $\cnt_{t+1}$ and the number of \inittxn transactions processed in the block so far.)
Note that to compute $\addr_i=H(\PK_i)=H(i,\upk_i,\tpk)$, the miner needs to have the correct $\upk_i$ which requires $O(n)$ storage.
We discuss how to avoid this in \cref{s:stateless-cryptocurrency:dos-update-key}.

\parhead{Transfering Coins via \spendtxn Transactions.}
When transferring $v$ coins to user $j$, user $i$ (who has $v'\ge v$ coins) must first obtain $\PK_j=(j, \upk_j,\tpk_j)$.
This is similar to existing cryptocurrencies, except the (full) public key is now slightly larger.
Then, user $i$ broadcasts a \spendtxn transaction, signed with her $\tsk_i$:
$$\tx=[\spendtxn, t, \PK_i, j, \upk_j, v,\pi_{i,t}, v']$$

A miner working on block ${t+1}$ who receives this \spendtxn transaction, proceeds as follows:
\begin{enumerate}
\item He checks that $v\le v'$ and verifies the proof $\pi_{i,t}$ that user $i$ has $v'$ coins via $\vcverifypos(\vrk, d_t, (\addr_i|v'), i, \pi_{i,t})$, where $\addr_i=H(\PK_i)$.
(If the miner receives another transaction from user $i$, it needs to carefully account for $i$'s new $v'-v$ balance.)
\item He updates $i$'s balance in block $t+1$ with $d_{t+1}=\vccommupdate(d_{t+1}, -v, i, \upk_i)$,
(Note that this only sets the lower order bits of $v_i$ corresponding to $\bal_i$, not touching the higher order bits for $\addr_i$.)
\item He updates $j$'s balance in block $t+1$ with $d_{t+1}=\vccommupdate(d_{t+1}$, $+v, j, \upk_j)$.
\end{enumerate}

\parhead{Validating Blocks.}
Suppose a miner receives a new block $t+1$ with digest $d_{t+1}$ that has $b$ transactions of the form:
$$\tx=[\spendtxn, t, \PK_{i}, {j}, \upk_{j}, v, \pi_{i,t}, v']$$
(We are ignoring \inittxn transactions, for now.)
To validate this block, the miner (who has $d_t$) proceeds in three steps:

\paragraph{Step 1: Check Balances.}
First, for each $\tx$, he checks that $v \le v'$ and that user $i$ has balance $v'$ via $\vcverifypos(\vrk, d_t$, $(\addr_{i}|v'), i, \pi_{i,t})=T$.
Since the sending user $i$ might have multiple transactions in the block, the miner has to carefully keep track of each sending user's balance to ensure it never goes below zero.

\paragraph{Step 2: Check Digest.}
Second, he checks $d_{t+1}$ has been computed correctly from $d_t$ and from the new transactions in block $t+1$.
Specifically, he sets $d'=d_t$ and for each $\tx$, he computes $d' = \vccommupdate(d', -v, i, \upk_{i})$ and $d'=\vccommupdate(d',+v$, $j,\upk_{j})$.
Then, he checks that $d'=d_{t+1}$.
(Finally, the miner can similarly verify and ``apply'' \inittxn transactions.)

\paragraph{Step 3: Updated Proofs, If Any.}
If the miner was racing to build block $t+1$ and lost, the miner can start mining block $t+2$ by ``moving over'' the \spendtxn transactions from his unmined block $t+1$.
For this, he has to update all proofs in those \spendtxn transactions, so they are valid against the new digest $d_{t+1}$.
Similarly, the miner must also ``move over'' all \inittxn transactions, since block $t+1$ might have registered new users.

\parhead{Catching Up With New Blocks.}
Consider a user $i$ who has processed the blockchain up to time $t$ and has digest $d_t$ and proof $\pi_{i,t}$.
Eventually, she receives a new block $t+1$ with digest $d_{t+1}$ and needs to update her proof so it verifies against $d_{t+1}$.
Initially, she sets $\pi_{i,t+1} = \pi_{i,t}$.
For each $[\inittxn,\PK_j]$ transaction, she updates her proof $\pi_{i,t+1} = \vcproofupdate(\pi_{i,t+1}, (H(\PK_j)|0), j, \upk_j)$.
For each $[\spendtxn, t, \PK_j, k, \upk_k, v,\pi_{j,t}, v']$, she updates her proof twice: $\pi_{i,t+1} =\vcproofupdate(\pi_{i,t+1}, -v, j, \upk_j)$ and $\pi_{i,t+1} =\vcproofupdate(\pi_{i,t+1}, +v, k, \upk_k)$.

We stress that users can safely be offline and miss new blocks.
Eventually, when a user comes back online, she downloads the missed blocks, updates her proof and is ready to transact.

\subsection{Efficient Stateless Cryptocurrencies from aSVCs}
In this subsection, we explain how replacing the Edrax VC with our aSVC from \cref{s:asvc:from-kzg} results in a more efficient stateless cryptocurrency (see \cref{t:stateless-comparison}).
Then, we address a denial of service attack on user registrations in Edrax.

\subsubsection{Smaller, Faster, Aggregatable Proofs}
Since our aSVC proofs are aggregatable, miners can aggregate all $b$ proofs in a block of $b$ transactions into a single, constant-sized proof using \vcaggregateproofs.
This drastically reduces Edrax's per-block proof overhead from $O(b\log{n})$ group elements to just one group element.
Unfortunately, the $b$ update keys cannot be aggregated, adding $b$ group elements of overhead per block (see \cref{s:stateless-cryptocurrency:smaller-update-keys}).
Nonetheless, this is still an improvement over Edrax, which had $O(b\log{n})$ overhead.

Our smaller proofs are also faster to update, taking $O(1)$ time rather than $O(\log{n})$.
While verifying an aggregated proof is $O(b\log^2{b})$ time, which is asymptotically slower than the $O(b)$ time for verifying $b$ individual ones, it is still \textit{concretely} faster as it only requires two cryptographic pairings rather than $b$.
This makes validating new blocks much faster.

\subsubsection{Reducing Miner Storage Using Verifiable Update Keys}
\label{s:stateless-cryptocurrency:dos-update-key}

Recall that miners need update keys to update the digest when processing and validating \inittxn and \spendtxn transactions.
Importantly, miners should validate an update key before using it.
Otherwise, updating a digest with an incorrect update key will corrupt that digest, leading to a denial of service attack.
To address this, Edrax miners store all $O(n)$ update keys, which makes validating any update key trivial.
Alternatively, Edrax can outsource update keys to an untrusted third party (e.g., via a Merkle tree) and miners can verifiably fetch them on demand.
Unfortunately, this would require interaction \textit{during block proposal and block validation}, which we believe is unacceptable.

Our design avoids the $O(n)$ storage and (most of) the interaction by outsourcing the update keys, but in a different fashion than Edrax.
Specifically, since our update keys are verifiable, we do not need the overhead of Merkle tree-based authentication.
To handle \spendtxn transactions, miners simply verify the update keys included in the transaction via \vcverifyupk.
In contrast, in Edrax, miners either have to store all update keys or verify them by asking for a Merkle proof from third parties, which requires interaction during block proposal and validation.
Alternatively, each Edrax user can include Merkle proofs in their transaction, but this increases transaction size and makes transacting interactive, which Edrax is designed to avoid.

Furthermore, for \inittxn transactions, miners can fetch (in the background) a running window of the next $k$ update keys needed for the next $k$ \inittxn transactions.
Importantly, this does not require any interaction during the block proposal, as the update keys are fetched in the background by upper-bounding the number of \inittxn transactions expected in the near future.
This background fetching could also be implemented in Edrax, but with additional overhead from Merkle proofs.
(Unless the Edrax update keys are made verifiable too, which seems possible.)

\subsubsection{Smaller Update Keys}
\label{s:stateless-cryptocurrency:smaller-update-keys}
Recall that $\upk_i$ contains $a_i=g^{A(\tau)/(X-\omega^i)}$ and $u_i=g^{\frac{\lagr_i(\tau)-1}{X-\omega^i}}$ in our aSVC.
We observe that miners only need to include $a_i$ in the block.
This is because of two reasons.
First, user $i$ already has $u_i$ to update her own proof after changes to her own balance.
Second, no other user $j\ne i$ will need $u_i$ to update her proof $\pi_j$.
However, as hinted above, miners might actually need $u_i$
(e.g., when a subset of $i$'s pending transactions get included in block $t$ and the remaining transactions for block $t+1$ must have their proofs updated).
Fortunately, this is not a problem, since miners always receive $u_i$ with user $i$'s transactions.
The key observation is that they do not have to include $u_i$ in the mined block, since users do not need it.

\subsubsection{Addressing DoS Attacks on User Registrations.}
\label{s:stateless-cryptocurrency:dos-registration}

Unfortunately, the registration process based on \inittxn transactions is susceptible to Denial of Service (DoS) attacks:
an attacker can simply send a large number of \inittxn transactions and quickly exhaust the free space in the vector $\vect{v}$.
One way to address this is to use a hidden-order based VC which supports an unbounded number of elements.
However, that would negatively impact performance.
Yet another way, is to develop authenticated dictionaries \textit{with scalable updates}.
This is left as future work.

For bounded VCs such as ours, we address this by adding a cost to user registrations.
A simple solution would be to register users by transferring a minimum amount of coins to their soon-to-be-registered TPKs via a different kind of \spendtxn transaction.
In other words, \inittxn transactions should be more like \spendtxn transactions that send coins to a soon-to-be-registered user $j$.
Thus, we propose a new \initspendtxn transaction type that does exactly this:
$$[\initspendtxn, t, \PK_i, \tpk,v,\pi_{i,t}, v'],\ \text{where}\ 0 < v \le v'$$
User $i$ would sign this \initspendtxn transaction using her $\tpk_i$, similar to a \spendtxn transaction.
Miners processing this transaction would (1) first register a new user $j$ with traditional public key $\tpk$ and (2) transfer $v$ coins to $j$.

Finally, miners (and only miners) will be allowed to create a \textit{single} $[\inittxn, \PK_i]$ transaction per block to register themselves.
This has to be the case if new miners are to be able to join without ``permission'' from other miners or users.
As a result, DoS attacks are severely limited, since malicious miners can only register a new account per block (which is already the case in UTXO-based cryptocurrencies~\cite{Nakamoto08}).
Furthermore, transaction fees and/or additional proof-of-work can also severely limit the frequency of \initspendtxn transactions.

\parhead{Limitations.}
This approach has the unfortunate side-effect of allowing user $j$ to register multiple accounts under the same \tpk.
Furthermore, user $j$ might do so accidentally, as he distributes his \tpk instead of his $\PK_j$ to other users to pay her.
We believe this issue could be addressed either through a careful user interface design or by ensuring that each \tpk is only registered once, perhaps via a \textit{cryptographic accumulator}~\cite{Bd93,Nguyen05} built over all TPKs.
Certainly, this issue could be side-stepped if the VC is replaced with an authenticated dictionary, which does not require \inittxn transactions.
We leave this as future work.

\subsubsection{Minting Coins and Transaction Fees.}
Support for minting new coins can be easily added by introducing a new \minttxn transaction type:
$$\tx = [\minttxn, i, \upk_i, v]$$
Here, $i$ is the miner's user account number and $v$ is the amount of newly minted coins.
(Note that miners, just like users, must register using $\inittxn$ transactions if they are to receive block rewards.)
When this \minttxn transaction is processed by other users or miners, they update their digest $d_t$ using $\vccommupdate(d_t, +v, i, \upk_i)$.
(In addition, users also update their proofs.)
To support transaction fees, we can extend the \spendtxn transaction format to include a fee, which is then added with the miner's block reward specified in the \minttxn transaction.

\subsection{Discussion}

\subsubsection{Making Room for Transaction Counters}
\label{s:discussion:txn-counters}
As mentioned in \cref{s:prelim:stateless-cryptocurrency}, to prevent transaction replay attacks, account-based stateless cryptocurrencies such as Edrax should actually map a user $i$ to $v_i = (\addr_i\vert c_i\vert\bal_i)$, where $c_i$ is her \textit{transaction counter}.
This change is trivial, but does leave less space in $v_i$ for $\addr_i$, depending on how many bits are needed for $c_i$ and $\bal_i$.
(Recall that $v_i\in\Zp$ typically has $\approx$ 256 bits.)

This can be addressed by having two VCs rather than one: one VC for mapping $i$ to $\addr_i$ and another for mapping $i$ to $(c_i\vert\bal_i)$.
Our key observation is that the two VCs should use different $n$-SDH params, one with base $g$ and another with base $h$, such that $\mathsf{DiscreteLog}_g(h)$ is unknown.
This would allow aggregating the VCs, their proofs and their update keys, so as to introduce zero computational and communication overhead in our stateless cryptocurrency.

The security of this scheme should naturally follow from the information-theoretically hiding flavor of KZG commitments~\cite{KZG10a}, which commits to $\phi(X)$ as $g^{\phi(\tau)}h^{r(\tau)}$ in a similar fashion.
However, we leave investigating the details of such a scheme to future work.

\subsubsection{Overhead of Synchronizing Proofs}
\label{s:stateless-cryptocurrency:proof-serving-nodes}
In a stateless cryptocurrency, users need to keep their proofs updated w.r.t. the latest block.
Asymptotically, each user spends $O(b\cdot \Delta{t})$ time updating her proof, if there are $\Delta{t}$ new blocks of $b$ transactions each.
Fortunately, when the underlying VC scheme supports precomputing all $n$ proofs fast~\cite{CPZ18,TCZ+20}, this overhead can be shifted to untrusted third parties called \textit{proof serving nodes}~\cite{CPZ18}.
Specifically, a proof serving node would have access to the proving key \prk and periodically compute all proofs for all $n$ users.
Then, any user with an out-of-sync proof could ask a node for their proof and then manually update it, should it be slightly out of date with the latest block.
Proof serving nodes save users a significant amount of proof update work, which is important for users running on constrained devices such as mobile phones.
